{"version":3,"sources":["containers/Face/faces/dog-off.jpg","containers/Face/faces/dog-listening.jpg","containers/Face/faces/dog-waiting.jpg","containers/Face/faces/dog-thinking.jpg","containers/Face/faces/dog-speaking.jpg","helpers/webVoiceProcessor.js","helpers/porcupineManager.js","moods/Waiting.js","helpers/hotWordDetection.js","moods/Listening.js","helpers/intentHandler.js","fulfillment/EasterEggsFulfillment.js","moods/Thinking.js","moods/Speaking.js","containers/Face/index.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","porcupineWorkerScript","downsamplingScript","porcupineWorker","WebVoiceProcessor","downsampler","isRecording","start","engines","downsamplerScript","errorCallback","audio","stream","audioContext","window","AudioContext","webkitAudioContext","audioSource","createMediaStreamSource","node","createScriptProcessor","onaudioprocess","e","postMessage","command","inputFrame","inputBuffer","getChannelData","connect","destination","Worker","inputSampleRate","context","sampleRate","onmessage","forEach","engine","data","stop","webVoiceProcessor","keywordIDs","sensitivities","detectionCallback","keyword","Waiting","props","componentDidMount","console","log","mood","moodHandler","startHotWordDetection","componentDidUpdate","prevProps","prepareForNewConversation","stopHotWordDetection","toggleDemo","changeStateFromWaitingToListening","hotWordDetector","Uint8Array","Float32Array","processCallback","PorcupineManager","process","downsamplingWorker","porcupineManager","audioManagerErrorCallback","ex","alert","toString","HotwordDetection","this","onClick","React","Component","Listening","handleListen","recognition","finalTranscript","onresult","event","i","resultIndex","results","length","transcript","isFinal","queryHandler","onend","SpeechRecognition","webkitSpeechRecognition","continous","interimResults","lang","intentMap","Map","set","a","async","joke","options","method","url","headers","Connection","Referer","Accept","rp","then","res","JSON","parse","mainIntentHandler","standardFulfillment","intent","endCoversation","entities","fulfillmentHandler","has","get","fulfillment","fulfillmentText","name","showRecentSightings","showTickerTape","boolval","undefined","fields","end_conversation","boolValue","Thinking","handleIntent","query","params","axios","post","fulfillmentMessage","queryResult","fulfillmentMessages","message","concat","text","displayName","endConversation","diagnosticInfo","parameters","stringify","catch","err","Speaking","msg","SpeechSynthesisUtterance","speechSynthesis","speak","endAudio","end","audioHandler","setState","audiosrc","getAudio","state","src","onEnded","autoPlay","images","off","listening","waiting","thinking","speaking","Face","loadedImages","loading","offsetX","offsetY","move","componentWillMount","Object","entries","image","img","Image","onload","componentWillUnmount","x","y","update","timing","duration","ease","offset","easeExpOut","easeCubicOut","BgImage","status","alt","styled","className","style","left","bottom","height","width","Controller","person","showTickertape","personOfInterest","startListening","onClickRecentSightings","showInhubitants","forceHideRecentSightings","Button","zIndex","position","right","top","color","Boolean","location","hostname","match","theme","createMuiTheme","palette","type","ReactDOM","render","ThemeProvider","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.64bc74eb.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/dog-off.fbfd34ba.jpg\";","module.exports = __webpack_public_path__ + \"static/media/dog-listening.add4fedf.jpg\";","module.exports = __webpack_public_path__ + \"static/media/dog-waiting.32833b10.jpg\";","module.exports = __webpack_public_path__ + \"static/media/dog-thinking.aae2d64d.jpg\";","module.exports = __webpack_public_path__ + \"static/media/dog-speaking.5c1ee2e0.jpg\";","navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\r\n\r\n// TODO: refactor this to hotWordDetection.js to keep it in one script since we only use it once?\r\n\r\n\r\nexport default function () {\r\n    let downsampler;\r\n\r\n    let isRecording = false;\r\n\r\n    let start = function (engines, downsamplerScript, errorCallback) {\r\n        if (!downsampler) {\r\n            navigator.getUserMedia(\r\n                {audio: true},\r\n                stream => {\r\n                    let audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n                    let audioSource = audioContext.createMediaStreamSource(stream);\r\n                    let node = audioContext.createScriptProcessor(4096, 1, 1);\r\n                    node.onaudioprocess = function (e) {\r\n                        if (!isRecording) {\r\n                            return;\r\n                        }\r\n\r\n                        downsampler.postMessage({command: 'process', inputFrame: e.inputBuffer.getChannelData(0)});\r\n                    };\r\n                    audioSource.connect(node);\r\n                    node.connect(audioContext.destination);\r\n\r\n                    downsampler = new Worker(downsamplerScript);\r\n                    downsampler.postMessage({command: 'init', inputSampleRate: audioSource.context.sampleRate});\r\n                    downsampler.onmessage = function (e) {\r\n                        engines.forEach(function (engine) {\r\n                            engine.postMessage({command: \"process\", inputFrame: e.data});\r\n                        });\r\n                    };\r\n                },\r\n                errorCallback);\r\n        }\r\n\r\n        isRecording = true;\r\n    };\r\n\r\n    let stop = function () {\r\n        isRecording = false;\r\n        downsampler.postMessage({command: 'reset'});\r\n    };\r\n\r\n    return {start: start, stop: stop};\r\n}\r\n","import webVoiceProcessor from './webVoiceProcessor'\r\n\r\n// TODO: refactor this to hotWordDetection.js to keep it in one script since we only use it once?\r\n\r\nexport default function (porcupineWorkerScript, downsamplingScript) {\r\n    const WebVoiceProcessor = webVoiceProcessor()\r\n    let porcupineWorker;\r\n\r\n    let start = function (keywordIDs, sensitivities, detectionCallback, errorCallback) {\r\n        porcupineWorker = new Worker(porcupineWorkerScript);\r\n        porcupineWorker.postMessage({\r\n            command: 'init',\r\n            keywordIDs: keywordIDs,\r\n            sensitivities: sensitivities\r\n        });\r\n\r\n        porcupineWorker.onmessage = function (e) {\r\n            detectionCallback(e.data.keyword);\r\n        };\r\n\r\n        WebVoiceProcessor.start([porcupineWorker], downsamplingScript, errorCallback);\r\n    };\r\n\r\n    let stop = function () {\r\n        WebVoiceProcessor.stop();\r\n        porcupineWorker.postMessage({command: \"release\"});\r\n    };\r\n\r\n    return {start: start, stop: stop}\r\n}\r\n","import React from 'react';\r\nimport HotwordDetection from '../helpers/hotWordDetection.js';\r\n\r\n\r\nclass Waiting extends React.Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        // initialising the Hotword Detector with the completion handler that changes the state from waiting to listening\r\n        this.hotWordDetector = HotwordDetection(this.changeStateFromWaitingToListening) \r\n    }\r\n\r\n\r\n    // changeStateToWaiting = () => {\r\n    //     this.props.moodHandler(\"waiting\")\r\n    // }\r\n\r\n    //mount function - supposed to do initialization but we'll get to it later\r\n    componentDidMount = () => {\r\n        console.log(\"component mounted\")\r\n        if (this.props.mood === \"initializing\") {\r\n            this.props.moodHandler(\"waiting\")\r\n            console.log(\"*** MOOD : WAITING ***\")\r\n            this.startHotWordDetection()\r\n        }\r\n    }\r\n\r\n    //this function is called whenever there is an update in state in any component\r\n    componentDidUpdate = (prevProps) => {\r\n        // if there is a change from any mood to \"waiting\"\r\n        if (this.props.mood === \"waiting\" && prevProps.mood !== this.props.mood) {\r\n            //prepare for a new conversation. that is, make sure that end of conversation is false since we are starting a new conversation\r\n            this.props.prepareForNewConversation()\r\n            console.log(\"*** MOOD : WAITING ***\")\r\n            // and since we are in the waiting mood, start hot word detection\r\n            this.startHotWordDetection()\r\n        }\r\n        // if there is a change of mood from waiting --> off\r\n        else if (this.props.mood === \"off\" && prevProps.mood === \"waiting\" ) {\r\n            //it means that hotword detection is still on (because the waiting state starts hotword detection). We must turn it off since we are going to the off state\r\n            this.stopHotWordDetection()\r\n        }\r\n        else if (this.props.mood === \"listening\" && prevProps.mood === \"waiting\" ) {\r\n            //it means that hotword detection is still on (because the waiting state starts hotword detection). We must turn it off since we are going to the off state\r\n            this.stopHotWordDetection()\r\n        }\r\n\r\n    }\r\n\r\n    toggleDemo = () => {\r\n        // puts up \"demo screen\" in debug mode. as of now, never used.\r\n        if (this.props.mood === \"off\") {\r\n            this.props.moodHandler(\"waiting\")\r\n            this.startHotWordDetection()\r\n        }\r\n        else {\r\n            this.stopHotWordDetection()\r\n            this.props.moodHandler(\"off\")\r\n        }\r\n    }\r\n\r\n\r\n    // toggleWait(){\r\n    //     if (this.props.mood === \"waiting\"){\r\n    //         console.log(\"*** MOOD : WAITING ***\")\r\n    //         this.props.moodHandler(\"listening\")\r\n\r\n    //     }\r\n\r\n    // }\r\n\r\n    //this is the completion handler passed to HotWordDetector\r\n    changeStateFromWaitingToListening = () => {\r\n        // completion handler for Hotword Detector\r\n        this.props.moodHandler(\"listening\")\r\n    }\r\n\r\n    //starts HotWordDetection only if you are in the waiting mood\r\n    startHotWordDetection = () => {\r\n        // TODO: implement stop() too\r\n        if (this.props.mood === \"waiting\") {\r\n            this.hotWordDetector.start()\r\n        }\r\n        else{\r\n            console.log(\"Waiting.js startHotWordDetection(): you cant start hotword detection because you are not in the waiting mood!\")\r\n        }\r\n\r\n    }\r\n\r\n    //stopsHotWordDetection\r\n    stopHotWordDetection = () => {\r\n        // TODO: implement stop() too\r\n        console.log(\"*** MOOD : OFF ***\")\r\n        this.hotWordDetector.stop()\r\n        \r\n    }\r\n\r\n\r\n    render() {\r\n\r\n        let button\r\n\r\n        if (this.props.mood === \"off\") {\r\n            button = <button onClick={this.toggleDemo}>On Demo</button>\r\n        } else {\r\n            button = <button onClick={this.toggleDemo}>Off Demo</button>\r\n        }\r\n\r\n\r\n        return (\r\n            <>\r\n                {/* <h2>Waiting</h2>\r\n                {button} */}\r\n            </>\r\n        )\r\n    }\r\n}\r\n// FUTURE: button styling\r\n\r\n\r\nexport default Waiting","import porcupineManager from './porcupineManager'\r\n\r\nexport default function HotwordDetection(changeStateFromWaitingToListening) {\r\n    let keywordIDs = {\r\n        'hey pico': new Uint8Array([\r\n            0x28, 0x03, 0x80, 0xae, 0x56, 0x8d, 0x60, 0xaf, 0x14, 0x00, 0x26, 0xf2,\r\n            0x2d, 0x99, 0xbf, 0x83, 0xa5, 0x90, 0x65, 0xc8, 0x06, 0x2c, 0xc7, 0xd8,\r\n            0x5b, 0x2e, 0x4d, 0x11, 0x1b, 0xab, 0x99, 0xb3, 0xce, 0x93, 0x31, 0x01,\r\n            0x53, 0x45, 0x6c, 0x1a, 0xad, 0xab, 0x13, 0x9c, 0xcb, 0xb2, 0xd4, 0x37,\r\n            0x59, 0xc1, 0x5a, 0xf3, 0x1f, 0xe2, 0xb9, 0xcf, 0xda, 0x56, 0x2f, 0x72,\r\n            0x7c, 0xa8, 0x51, 0xb5, 0xe2, 0xf8, 0x0b, 0x86, 0x0e, 0xf6, 0x0c, 0xc5,\r\n            0xc3, 0x94, 0x44, 0x69, 0x6c, 0xd8, 0xf5, 0xa8, 0xc9, 0x09, 0x41, 0x5d\r\n        ])\r\n    };\r\n\r\n    let sensitivities = new Float32Array([0.5, 1, 1, 1, 1, 1]);\r\n\r\n\r\n    let processCallback = function (keyword) {\r\n        if (keyword === null) {\r\n            console.log(\"No hotword detected\")\r\n            return;\r\n        }\r\n\r\n\r\n        // if the hotword is found, change the state from waiting to listening and stop hotword detection\r\n        if (keyword === \"hey pico\") {\r\n            changeStateFromWaitingToListening()\r\n            console.log(\"hey pico detected\")\r\n            PorcupineManager.stop();\r\n        }\r\n\r\n    };\r\n\r\n\r\n    const porcupineWorker = `${process.env.PUBLIC_URL}/porcupine_worker.js`\r\n    const downsamplingWorker = `${process.env.PUBLIC_URL}/downsampling_worker.js`\r\n\r\n\r\n    const PorcupineManager = porcupineManager(\r\n        porcupineWorker,\r\n        downsamplingWorker\r\n    )\r\n\r\n    let audioManagerErrorCallback = function (ex) {\r\n        alert(ex.toString());\r\n    };\r\n\r\n    let start = function () {\r\n        PorcupineManager.start(keywordIDs, sensitivities, processCallback, audioManagerErrorCallback);\r\n\r\n    };\r\n\r\n    let stop = function () {\r\n        PorcupineManager.stop();\r\n        console.log(\"stopped hotword detection\")\r\n    };\r\n\r\n    return { start: start, stop: stop }\r\n}\r\n","import React from 'react';\r\n\r\nclass Listening extends React.Component {\r\n\r\n  constructor(props) {\r\n    super(props)\r\n\r\n    //here we get the SpeechRecognition interface from the web speech api\r\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition\r\n    // using the SpeechRecognition interface, we create an instance of SpeechRecognition called recognition. This was done in the constructor so that in the future, you can set the language of the recognition service\r\n    this.recognition = new SpeechRecognition()\r\n\r\n    //following this is just a bunch of parameteres that are set \r\n    this.recognition.continous = true\r\n    this.recognition.interimResults = true\r\n    // language of recognition english\r\n    this.recognition.lang = 'en-US'\r\n  }\r\n\r\n\r\n   //this function is called whenever there is an update in state in any component\r\n  componentDidUpdate = (prevProps) => {\r\n     // if there is a change from any mood to \"listening\"\r\n    if (this.props.mood === \"listening\" && prevProps.mood !== this.props.mood) {\r\n      console.log(\"*** MOOD : LISTENING ***\")\r\n        \r\n      this.handleListen()\r\n\r\n    }\r\n    else {\r\n      // if there is a change in state to any other mood that is not listening, ensure that you turn off the speech recognition\r\n      this.recognition.stop()\r\n      // console.log(\"Listening: do nothing\")\r\n    }\r\n  }\r\n\r\n  //handles Listening - from getting the speech to text to setting the query in the controller using queryHandler\r\n  handleListen = () => {\r\n\r\n    //starts voice recognition\r\n    this.recognition.start()\r\n    console.log(\"start of voice recognition\")\r\n\r\n    let finalTranscript = ''\r\n\r\n    //event handler for results. Everything the recognition object detects speech, this will fire with the results of the speech to text stored in event.results\r\n    this.recognition.onresult = event => {\r\n      let interimTranscript = ''\r\n\r\n      for (let i = event.resultIndex; i < event.results.length; i++) {\r\n        const transcript = event.results[i][0].transcript;\r\n        // console.log(\"transcript, \" + transcript)\r\n\r\n        //this if condition is only met when end of utterance is detected. Hence, this bunch of code only runs after the entire speech to text is complete\r\n        if (event.results[i].isFinal) {\r\n          finalTranscript += transcript + ' ';\r\n\r\n          //upon end of utterance, set the controller's state.query to the query and change the mood\r\n          this.props.queryHandler(finalTranscript)\r\n          this.props.moodHandler(\"thinking\")\r\n\r\n        }\r\n\r\n        else interimTranscript += transcript;\r\n      }\r\n\r\n      // document.getElementById('interim').innerHTML = interimTranscript\r\n      // document.getElementById('final').innerHTML = finalTranscript\r\n\r\n    }\r\n\r\n    //event handler when the recognition service ends\r\n    this.recognition.onend = event => {\r\n      console.log('Speech recognition service disconnected');\r\n      //if the mood is still listening, it means that the speech service hasnt detected any speech for 5 seconds which causes the recognition to end without getting any query. \r\n      //Hence, the if condition in recognition.onresult is never met and mood is never changed. we need to account for this case\r\n      if (this.props.mood === \"listening\") {\r\n\r\n        //this sends the query \"\" and changes the mood to thinking. the fulfillment would be a prompt to get them to say something else.\r\n        this.props.queryHandler(\"\")\r\n        this.props.moodHandler(\"thinking\")\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        {/* <h2>Listening</h2>\r\n        <button className='btn' onClick={this.toggleListen}>Listen</button>\r\n        <div id=\"interim\" className=\"mysterybox\" ></div>\r\n        <div id=\"final\" className=\"mysterybox\"></div> */}\r\n      </>\r\n    )\r\n  }\r\n}\r\n\r\n\r\n\r\nexport default Listening","//we import the fulfillmentHandlers from the different files in fulfillment. If there is a way to automate this such that it automatically imports all functions in fulfillment, that would be great!\r\nimport {handleEastereggJoke} from '../fulfillment/EasterEggsFulfillment'\r\n\r\n//with all the fulfillmentHandlers we import above, we create an intent map, mapping each intent to each handler\r\nconst intentMap = new Map();\r\nintentMap.set('Jokes', handleEastereggJoke);\r\n\r\n\r\nasync function mainIntentHandler(standardFulfillment, intent, endCoversation, entities, fulfillmentHandler){\r\n\r\n    //if the intent is found in the intent map, we handle the intent locally\r\n    if (intentMap.has(intent)){\r\n        console.log(\"intentHandler: intent handled locally\")\r\n        //*** */handle intent locally\r\n\r\n        // TODO: clean this up\r\n        //get the intent from the intentmap, and then pass the entities into the function. the function should return a fulfillment\r\n        intentMap.get(intent)(entities).then( fulfillment => {\r\n                //there will be two types of fulfillment that might from this. one takes the form of a string, and the other an array\r\n                if (typeof fulfillment == \"string\"){\r\n                    //if it is a string, just send the fulfillment into the fulfillmentHandler\r\n                    fulfillmentHandler(fulfillment, false)\r\n                }\r\n                else{\r\n                    //else, it means that its a handler that controls the UI of enciq (eyeball stuff). pass all the elements in the array as arguments to fulfillmentHandler to update the controller's state accordingly\r\n                    const [fulfillmentText, name, showRecentSightings, showTickerTape] = fulfillment\r\n                    fulfillmentHandler(fulfillmentText, false, name, showRecentSightings, showTickerTape)\r\n                }\r\n                //if you forgot, fulfillmentHandler is a completion handler passed down here from App.js (Controller) --> Thinking.js (Thinking) --> mainIntentHandler (here!)\r\n                //hence, it updates the fulfillmentText in the controller\r\n            \r\n        })\r\n        \r\n\r\n    }\r\n    // if the intent is not found in the intent map, we use the fulfillment that was given by dialogflow\r\n    else{\r\n        console.log(\"intentHandler: intent handled by dialogflow\")\r\n        //*** */do normal dialogflow fulfillment    \r\n\r\n        let boolval = true\r\n        // console.log(\"endCoversation, \" + JSON.stringify(endCoversation))\r\n        // console.log(\"fulfillment, \" + JSON.stringify(fulfillment))\r\n\r\n        //check for end of conversation. The structure of endConversation varies based on response so we check for the different type of structures that all correspond to \"its not the end of conversation\"\r\n        if (endCoversation === null || endCoversation.fields === undefined || endCoversation.fields.end_conversation === undefined){\r\n            boolval = false\r\n          }\r\n          // if endConversation.fields.end_conversation does exist, use the boolValue that is stored there to determine whether it is the end of conversation or not\r\n          else{\r\n            boolval = endCoversation.fields.end_conversation.boolValue\r\n          }\r\n        \r\n\r\n        //send fulfillment to controller\r\n        fulfillmentHandler(standardFulfillment, boolval)\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\nexport default mainIntentHandler","import rp  from 'request-promise';\r\n\r\n\r\nexport async function handleEastereggJoke() {\r\n    try {\r\n        let joke = \"What kind of horse only goes out at night? Nightmares\"\r\n\r\n        var options = {\r\n            method: 'GET',\r\n            url: 'https://cors-anywhere.herokuapp.com/http://icanhazdadjoke.com',\r\n            headers:\r\n            {\r\n                'cache-control': 'no-cache',\r\n                Connection: 'keep-alive',\r\n                Referer: 'http://icanhazdadjoke.com/',\r\n                'Accept-Encoding': 'gzip, deflate',\r\n                'Cache-Control': 'no-cache',\r\n                Accept: 'application/json'\r\n            }\r\n        };\r\n\r\n        joke = await rp(options).then( res => {\r\n            return JSON.parse(res).joke\r\n        })\r\n\r\n        return joke\r\n        \r\n    } catch (error) {\r\n        console.log(\"error, \", error)\r\n    }\r\n}\r\n\r\n\r\n","import React from 'react';\r\nimport axios from 'axios';\r\nimport mainIntentHandler from '../helpers/intentHandler.js'\r\n\r\n\r\nclass Thinking extends React.Component {\r\n\r\n    //this function is called whenever there is an update in state in any component\r\n    componentDidUpdate = (prevProps) => {\r\n        // if there is a change from any mood to \"thinking\"\r\n        if (this.props.mood === \"thinking\" && prevProps.mood !== this.props.mood) {\r\n            console.log(\"*** MOOD : THINKING ***\")\r\n            //call the handleIntent() function\r\n            this.handleIntent()\r\n        }\r\n\r\n    }\r\n\r\n    // in handle intent, we first send the query to dialogflow and then get the response. we then send the response to \"mainIntentHandler\", a helper function, who does the intent handling\r\n    handleIntent = async () => {\r\n\r\n        // first send the query to dialogflow as a HTTP request. The endpoint is a cloud function we created. it can be found in enciq-cloundfunc\r\n        let query = this.props.query\r\n\r\n        console.log(\"sending query: \", query)\r\n        let language = \"en-US\"\r\n        let params = {\r\n            \"query\": query,\r\n            \"languageCode\": language\r\n        }\r\n        await axios.post('https://us-central1-in-browser-voice-assistant-twb.cloudfunctions.net/dfReq', params).then(\r\n            res => {\r\n                //fulfillment messages in dialogflow can be found in one of two places in the response. Hence, what we do here is check which one to use. \r\n                //by default, we use the fulfillmentText in the response here, assigned to fulfillmentMessage\r\n                let fulfillmentMessage = res.data[0].queryResult.fulfillmentText\r\n                //TODO: test this if condition\r\n                //however, sometimes, there is no fulfillmentText which would render fulfillmentMessage as a empty string. \r\n                //In the case where fulfillmentMessage is empty, we look to another area of the response for the message\r\n                if (res.data[0].queryResult.fulfillmentText === \"\"){\r\n                    console.log(\"thinking: standard fulfillment message not available\")\r\n                    //the fulfillment message that we get in this part of the response is given in an array. Hence, we append each element of the array to create one fulfillmentMessage\r\n                    res.data[0].queryResult.fulfillmentMessages.forEach( message => {\r\n                        //concat means adding strings together\r\n                        fulfillmentMessage.concat(message.text.text[0])\r\n                        console.log(fulfillmentMessage)\r\n                    })\r\n                }\r\n\r\n\r\n                //here, we break the response into the components we use for intentHandling. intent, endConversation and entities\r\n                let intent = res.data[0].queryResult.intent.displayName\r\n                let endConversation = res.data[0].queryResult.diagnosticInfo\r\n                let entities = res.data[0].queryResult.parameters.fields\r\n                console.log(\"intent, \", intent)\r\n                console.log(\"entities, \", JSON.stringify(entities))\r\n\r\n                //we send the params into the mainIntentHandler, who will do the intent handling. We also pass the fulfillmentHandler down so that the intentHandler can set the fulfillment text of the controller upon finishing its handling\r\n                mainIntentHandler(fulfillmentMessage, intent, endConversation, entities, this.props.fulfillmentHandler) // TODO: await this?\r\n            }\r\n        ).catch( err => {\r\n            console.log(\"err\", err)\r\n            // enciq will say this if something goes wrong with dialogflow request\r\n            this.props.fulfillmentHandler(\"sorry babe, I didnt hear anything. Plase say that again\")\r\n        })\r\n        \r\n    }\r\n\r\n\r\n    render() {\r\n        return (\r\n            <>\r\n                {/* <h2>Thinking</h2>\r\n                <button className='btn' onClick={this.handleIntent}>Send</button> */}\r\n            </>\r\n        )\r\n    }\r\n}\r\n\r\n\r\n\r\nexport default Thinking","import React from 'react';\r\n// import { tts } from \"../helpers/TextToSpeech.js\"\r\n\r\nclass Speaking extends React.Component {\r\n\r\n    //this component has a\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            audiosrc: null\r\n        }\r\n\r\n        const speechSynthesis = window.speechSynthesis\r\n        \r\n    }\r\n\r\n    //this function is called whenever there is an update in state in any component\r\n    componentDidUpdate = (prevProps) => {\r\n        // if there is a change from any mood to \"speaking\"\r\n        if (this.props.mood === \"speaking\" && prevProps.mood !== this.props.mood) {\r\n            console.log(\"*** MOOD : SPEAKING ***\")\r\n            //do text to speech\r\n            // tts(this.props.fulfillmentText, this.audioHandler)\r\n            var msg = new window.SpeechSynthesisUtterance(this.props.fulfillmentText)\r\n            window.speechSynthesis.speak(msg)\r\n            this.endAudio()\r\n        }\r\n\r\n    }\r\n\r\n    //when audio is done playing, change state to either listening or waiting depending on value of \"end\"\r\n    endAudio = () => {\r\n        console.log(\"The audio has ended\");\r\n        // console.log(this.props.end)\r\n        // if it is end of conversation, go back to waiting state\r\n        if (this.props.end === true) {\r\n            this.props.moodHandler(\"waiting\")\r\n        }\r\n        // if its not end of conversation, go to listening state\r\n        else {\r\n            this.props.moodHandler(\"listening\")\r\n        }\r\n\r\n    }\r\n\r\n    //this is passed as a completion handler to tts(). it sets the audio source in this compoennt\r\n    audioHandler = (audio) => {\r\n        // console.log(\"audioHandler()\")\r\n        this.setState({\r\n            audiosrc: audio\r\n        })\r\n    }\r\n\r\n    //the getAudio() function is purely for debugging purposes\r\n    getAudio = () => {\r\n        console.log(\"getAudio()\")\r\n        // tts(\"Standard Fulfillment for debug\", this.audioHandler)\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <>\r\n\r\n                {/* <div id=\"fulfillment\" className=\"mysterybox\">{this.props.fulfillment}</div>\r\n                <h2>Speaking</h2>\r\n                <button onClick={this.getAudio}>Debug Button: Send Debug fulfillment</button>\r\n                <br />\r\n                <p>audio is: {this.state.audiosrc}</p>\r\n                <br /> */}\r\n                <audio src={this.state.audiosrc} onEnded={this.endAudio} autoPlay />\r\n            </>\r\n        )\r\n    }\r\n}\r\n\r\n\r\n\r\nexport default Speaking","import React, { Component } from 'react'\r\n\r\nimport styled from 'styled-components'\r\n\r\nimport off from './faces/dog-off.jpg'\r\nimport listening from './faces/dog-listening.jpg'\r\nimport waiting from './faces/dog-waiting.jpg'\r\nimport thinking from './faces/dog-thinking.jpg'\r\nimport speaking from './faces/dog-speaking.jpg'\r\n\r\nimport { Animate } from 'react-move'\r\nimport { easeExpOut, easeCubicOut } from 'd3-ease'\r\n\r\nconst images = {\r\n  off,\r\n  listening,\r\n  waiting,\r\n  thinking,\r\n  speaking\r\n}\r\n\r\nclass Face extends Component {\r\n  state = {\r\n    loadedImages: images,\r\n    loading: false,\r\n    offsetX: false,\r\n    offsetY: false,\r\n  }\r\n\r\n  move = (start, end) => {\r\n\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <Animate\r\n          start={() => ({\r\n            x: 0,\r\n            y: 0,\r\n          })}\r\n          update={() => ({\r\n            x: [this.props.offsetX ? 50 : 0],\r\n            y: [this.props.offsetY ? 20 : 0],\r\n            timing: { duration: 1300, ease: this.props.offset ? easeExpOut : easeCubicOut },\r\n          })}\r\n        >\r\n          {(state) => {\r\n            const { x, y } = state\r\n\r\n            return (\r\n              <BgImage\r\n                src={this.state.loadedImages[this.props.status]}\r\n                alt={'img'}\r\n                // offset={this.props.offset}\r\n                offsetX={x}\r\n                offsetY={y}\r\n              />\r\n            )\r\n          }}\r\n        </Animate>\r\n      </>\r\n    )\r\n  }\r\n\r\n  componentWillMount = () => {\r\n    Object.entries(images).forEach(([key, image]) => {\r\n      const img = new Image()\r\n      img.src = image\r\n\r\n      img.onload = () => {\r\n        console.log(image + ' loaded')\r\n      }\r\n    })\r\n  }\r\n\r\n  componentWillUnmount = () => {\r\n\r\n  }\r\n}\r\n\r\n\r\n\r\nconst BgImage = styled(({ className, alt, src, offsetX, offsetY, ...props }) => (\r\n  <div className={className} style={{ left: `${offsetX}%`, bottom: `${offsetY}%` }}>\r\n    <img  src={src} alt={alt} height = \"100%\" width = \"100%\" {...props} />\r\n  </div>\r\n))`\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  bottom: 0;\r\n  right: 0;\r\n  z-index: 0;\r\n\r\n  video {\r\n    width: 100%;\r\n    height: 100%;\r\n    object-fit: cover;\r\n  }\r\n\r\n  background-color: black;\r\n`\r\n\r\nexport default Face","import React from 'react';\r\nimport './App.css';\r\n\r\n\r\nimport Waiting from './moods/Waiting'\r\nimport Listening from './moods/Listening'\r\nimport Thinking from './moods/Thinking'\r\nimport Speaking from './moods/Speaking'\r\n\r\nimport Face from './containers/Face'\r\nimport Button from '@material-ui/core/Button';\r\nimport styled from 'styled-components'\r\n\r\nclass Controller extends React.Component {\r\n\r\n  constructor(props){\r\n    super(props);\r\n    this.state = {\r\n      mood: \"initializing\", // TODO: refactor as \"initializing\" for setState({mood: 'waiting'}) onMount after init all basic connections (i.e. speech token etc.)\r\n      query: null, // STT_query\r\n      fulfillmentText: null, // what enciq replies to user\r\n      end : false, // boolean demarking end of conversation\r\n\r\n      // eyeball states, default personOfInterest is roy. showInhubitants is not used\r\n      showInhubitants: false,\r\n      showRecentSightings: false,\r\n      showTickertape: false,\r\n      personOfInterest: 'roy'\r\n    }\r\n\r\n  }\r\n\r\n  //this is passed to all the mood components so that they can update the controller's mood state\r\n  moodHandler = (x) => {\r\n    // if mood is off, can only change to mood: waiting \r\n    if(this.state.mood === \"off\" && x !== \"waiting\"){\r\n      console.log(\"not allowed to change state\")\r\n    }\r\n    // if mood is anything but off, you have free reign to change it to anything\r\n    else{\r\n      this.setState({\r\n        mood: x\r\n      })\r\n    }\r\n\r\n  }\r\n\r\n  //passed to the listening component so that it can store the query in the controller\r\n  queryHandler = (query) => {\r\n    // completion handler for speech to text \r\n    this.setState({\r\n      query: query\r\n    })\r\n  }\r\n\r\n  //passed to the thinking component so that it can update fulfillment \r\n  fulfillmentHandler = (fulfillmentText, boolval, person, showRecentSightings, showTickertape) => {\r\n\r\n    // default - will always need to set end of conversation and fulfillment text\r\n    this.setState({\r\n      fulfillmentText: fulfillmentText,\r\n      end : boolval\r\n    })\r\n\r\n    //however, if values are passed in for showRecentSightings / showTickerTape, update the state here accordingly. this is for eyeball stuff\r\n    if (showRecentSightings !== null || undefined){\r\n      this.setState({\r\n        showRecentSightings: showRecentSightings,\r\n        personOfInterest: person\r\n      })\r\n    }\r\n\r\n    if (showTickertape !== null || undefined){\r\n      this.setState({\r\n        showTickertape: showTickertape\r\n      })\r\n    }\r\n\r\n    //TODO: make sure mood handling occurs in thinking instead\r\n    this.moodHandler(\"speaking\")\r\n  }\r\n\r\n\r\n  //When a conversation ends, \"this.state.end\" will be equal to true. Hence, when starting a new conversation, we need to re-initialize \"this.state.end\" to false\r\n  prepareForNewConversation = () => {\r\n    this.setState({\r\n      end: false\r\n    })\r\n  }\r\n\r\n  //this is the onClick function for the demo button. It allows the change of this.state.mood from [whateeverstate] --> off and from off --> waiting\r\n  toggleDemo = () => {\r\n    if (this.state.mood === \"off\") {\r\n        this.moodHandler(\"waiting\")\r\n    }\r\n    else {\r\n        this.moodHandler(\"off\")\r\n    }\r\n} \r\n\r\n  startListening = () => {\r\n    if (this.state.mood === \"waiting\") {\r\n      this.moodHandler(\"listening\")\r\n    }\r\n    else {\r\n      console.log(\"not allowed to change state unless in waiting\")\r\n    }\r\n  }\r\n\r\n// the onClick function for the recent sightings button. Is purely for debug purposes\r\n  onClickRecentSightings = () => {\r\n    this.state.showRecentSightings ? this.setState({ showRecentSightings: false, showInhubitants: false }) :\r\n      this.state.showInhubitants ?\r\n        this.setState({ showRecentSightings: true }) :\r\n        this.setState({ showRecentSightings: true, showInhubitants: true })\r\n  }\r\n\r\n\r\n  forceHideRecentSightings = () => {\r\n    this.setState({ showRecentSightings: false })\r\n  } \r\n\r\n\r\n\r\n\r\n  render() {\r\n\r\n    return (\r\n      <>\r\n        {/* picovoice */}\r\n        <Waiting mood={this.state.mood} moodHandler={this.moodHandler} prepareForNewConversation={this.prepareForNewConversation} /> \r\n        {/* SST */}\r\n        <Listening mood={this.state.mood} moodHandler={this.moodHandler} queryHandler={this.queryHandler} />\r\n        {/* Dialogflow */}\r\n        <Thinking mood={this.state.mood} moodHandler={this.moodHandler} query={this.state.query}  fulfillmentHandler={this.fulfillmentHandler} />\r\n        {/* TTS */}\r\n        <Speaking mood={this.state.mood} moodHandler={this.moodHandler} end={this.state.end} fulfillmentText={this.state.fulfillmentText} />\r\n\r\n\r\n        <Button\r\n          style={{ zIndex: '+2', position: 'absolute', right: 80, top: 0, color: '#6C3BFF' }}\r\n          onClick={this.startListening}>\r\n          Start Listening\r\n        </Button>\r\n\r\n\r\n        <Button\r\n          style={{ zIndex: '+2', position: 'absolute', right: 0, top: 0, color: '#6C3BFF' }}\r\n          onClick={this.toggleDemo}>\r\n          {this.state.mood}\r\n        </Button>\r\n\r\n        <Face\r\n          status={this.state.mood}\r\n          offsetX={this.state.showRecentSightings}\r\n          offsetY={this.state.showTickertape}\r\n        />\r\n\r\n      </>\r\n    )\r\n  }\r\n}\r\n\r\n// const Wrapper = styled.main`\r\n//   display: flex;\r\n//   flex-basis: 100%;\r\n//   // position: relative;\r\n//   background-color: black;\r\n//   background-size: cover;\r\n//   background-repeat: no-repeat;\r\n//   background-position: center center;\r\n// `\r\n\r\nexport default Controller;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport Controller from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nimport { createMuiTheme } from '@material-ui/core/styles';\r\nimport { ThemeProvider } from '@material-ui/styles';\r\n\r\nconst theme = createMuiTheme({\r\n  palette: {\r\n    type: 'dark', // Switching the dark mode on is a single property value change.\r\n  },\r\n});\r\n\r\n// TODO: update fonts and colours\r\n\r\nReactDOM.render(\r\n  <ThemeProvider theme={theme}>\r\n    <Controller />\r\n  </ThemeProvider>,\r\n  document.getElementById('root'));\r\n\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}